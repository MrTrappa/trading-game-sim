<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XAU/USD Trading Simulator</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial@4.0.1/dist/chartjs-chart-financial.min.js"></script>
    <style>
        body { background: #121212; color: #fff; font-family: sans-serif; text-align: center; }
        h1 { margin: 20px; }
        canvas { background: #222; border-radius: 10px; display: block; margin: 0 auto; }
        button {
            background: #1db954; color: #fff; border: none;
            padding: 12px 20px; margin: 10px; font-size: 16px;
            border-radius: 8px; cursor: pointer;
            transition: background 0.3s;
        }
        button:hover { background: #1ed760; }
        #leaderboard { background: #1c1c1c; padding: 10px; margin: 20px auto; width: 300px; border-radius: 10px; }
    </style>
</head>
<body>

<h1>üìà XAU/USD Trading Simulator</h1>
<p id="balance">Balance: $500</p>
<p id="position">Position: None</p>
<p id="unrealized">Unrealized PnL: $0</p>
<p id="timer">Time Left: 300s</p>

<canvas id="myChart" width="800" height="500"></canvas>

<div>
    <button onclick="startGame()">START GAME</button>
    <button onclick="goLong()">GO LONG</button>
    <button onclick="goShort()">GO SHORT</button>
    <button onclick="closePosition()">CLOSE POSITION</button>
</div>

<div id="leaderboard">
    <h3>üèÜ Leaderboard</h3>
    <ul id="leaderboardList"></ul>
</div>

<script>
    let balance = 500;
    let position = null;
    let leverage = 10;
    let gameOver = false;
    let timeLeft = 300;
    let intervalId;
    let timerId;
    let gameStarted = false;
    let leaderboard = JSON.parse(localStorage.getItem('leaderboard')) || [];
    let candles = [];
    let lastClose = 1900;

    const balanceDisplay = document.getElementById('balance');
    const positionDisplay = document.getElementById('position');
    const unrealizedDisplay = document.getElementById('unrealized');
    const timerDisplay = document.getElementById('timer');
    const leaderboardList = document.getElementById('leaderboardList');

    const ctx = document.getElementById('myChart').getContext('2d');
    const chart = new Chart(ctx, {
        type: 'candlestick',
        data: {
            datasets: [{
                label: 'XAU/USD',
                data: []
            }]
        },
        options: {
            animation: false,
            scales: {
                x: { ticks: { color: '#aaa' } },
                y: { ticks: { color: '#aaa' } }
            }
        }
    });

    function generateNextCandle(prevClose) {
        const open = prevClose;
        const high = open + Math.random() * 2;
        const low = open - Math.random() * 2;
        const close = low + Math.random() * (high - low);
        return { o: open, h: high, l: low, c: close, t: new Date().getTime() };
    }

    function startGame() {
        if (intervalId) clearInterval(intervalId);
        if (timerId) clearTimeout(timerId);

        gameStarted = true;
        gameOver = false;
        balance = 500;
        timeLeft = 300;
        position = null;
        lastClose = 1900;
        candles = [];

        balanceDisplay.textContent = `Balance: $${balance.toFixed(2)}`;
        positionDisplay.textContent = `Position: None`;
        unrealizedDisplay.textContent = `Unrealized PnL: $0`;
        timerDisplay.textContent = `Time Left: ${timeLeft}s`;

        chart.data.datasets[0].data = [];
        chart.update();

        intervalId = setInterval(updateChart, 3000);
        countdown();
    }

    function updateChart() {
        const nextCandle = generateNextCandle(lastClose);
        candles.push(nextCandle);
        chart.data.datasets[0].data.push(nextCandle);
        chart.update();
        lastClose = nextCandle.c;
        updateUnrealizedPnL();
    }

    function getCurrentPrice() {
        if (candles.length > 0) {
            return candles[candles.length -1].c;
        }
        return lastClose;
    }

    function goLong() {
        if (!gameStarted || gameOver) return;
        if (!position) {
            position = { type: 'LONG', entryPrice: getCurrentPrice() };
            positionDisplay.textContent = `Position: LONG @ $${position.entryPrice.toFixed(2)}`;
        } else { alert('Already holding a position!'); }
    }

    function goShort() {
        if (!gameStarted || gameOver) return;
        if (!position) {
            position = { type: 'SHORT', entryPrice: getCurrentPrice() };
            positionDisplay.textContent = `Position: SHORT @ $${position.entryPrice.toFixed(2)}`;
        } else { alert('Already holding a position!'); }
    }

    function closePosition() {
        if (!gameStarted || gameOver) return;
        if (position) {
            const exitPrice = getCurrentPrice();
            let profit = 0;
            if (position.type === 'LONG') {
                profit = (exitPrice - position.entryPrice) * leverage;
            } else {
                profit = (position.entryPrice - exitPrice) * leverage;
            }
            balance += profit;
            balanceDisplay.textContent = `Balance: $${balance.toFixed(2)}`;
            alert(`Closed ${position.type} for ${profit >= 0 ? '+' : ''}${profit.toFixed(2)}`);
            position = null;
            positionDisplay.textContent = `Position: None`;
            unrealizedDisplay.textContent = `Unrealized PnL: $0`;
        } else { alert('No open position!'); }
    }

    function updateUnrealizedPnL() {
        if (position) {
            const currentPrice = getCurrentPrice();
            let pnl = 0;
            if (position.type === 'LONG') {
                pnl = (currentPrice - position.entryPrice) * leverage;
            } else {
                pnl = (position.entryPrice - currentPrice) * leverage;
            }
            unrealizedDisplay.textContent = `Unrealized PnL: $${pnl.toFixed(2)}`;
        } else {
            unrealizedDisplay.textContent = `Unrealized PnL: $0`;
        }
    }

    function countdown() {
        if (gameOver) return;
        if (timeLeft <= 0) {
            endGame();
        } else {
            timeLeft--;
            timerDisplay.textContent = `Time Left: ${timeLeft}s`;
            timerId = setTimeout(countdown, 1000);
        }
    }

    function endGame() {
        if (!gameOver) {
            gameOver = true;
            clearInterval(intervalId);
            clearTimeout(timerId);
            alert(`Game Over!\nFinal Balance: $${balance.toFixed(2)}`);
            saveToLeaderboard(balance);
        }
    }

    function saveToLeaderboard(finalBalance) {
        leaderboard.push(finalBalance);
        leaderboard.sort((a,b) => b - a);
        leaderboard = leaderboard.slice(0,5);
        localStorage.setItem('leaderboard', JSON.stringify(leaderboard));
        renderLeaderboard();
    }

    function renderLeaderboard() {
        leaderboardList.innerHTML = '';
        leaderboard.forEach((score, index) => {
            const li = document.createElement('li');
            li.textContent = `#${index + 1}: $${score.toFixed(2)}`;
            leaderboardList.appendChild(li);
        });
    }

    renderLeaderboard();
</script>

</body>
</html>
